<?php
// $Id$

/**
 * @file
 * SMS Panel hooks implementations and helper API functions.
 */

/**
 * Module constants.
 * Defines placeholders for SMS message sending direction.
 */
define('SMS_PANEL_IN', 'IN');
define('SMS_PANEL_OUT', 'OUT');

/**
 * Implementation of hook_init().
 */
function sms_panel_init() {
  
}

/**
 * Implementation of hook_perm().
 */
function sms_panel_perm() {
  return array(
    'administer sms panel',
    'send sms message',
    'view outgoing message logs',
    'delete outgoing message logs',
    'view incoming message logs',
    'delete incoming message logs',
  );
}

/**
 * Implementation of hook_sms_send_alter().
 *
 * This is a temporary implementation since 
 * we're using a patched version of the smsframework and
 * it's not available in the original version.
 *
 * @param $outgoing
 *   An array of following data passed by reference:
 *   - number: Phone number of recipient.
 *   - message: SMS text body.
 *   - response: The response of gateway's send callback.
 */
function sms_panel_sms_send_alter(&$outgoing, $op) {
  if ($op == 'pre send' && !user_access('send sms message')) {
    drupal_set_message(t('You have not enough permission to send SMS messages.'), 'error', FALSE);
    
    // TODO: Just change the following lines!
    drupal_goto($_SERVER['HTTP_REFERER']);
    exit();
  }
  
  else if ($op == 'post send' && $outgoing['response']) {
    global $user;
    $gateway = sms_default_gateway();
    
    $sms = new stdClass();
    $sms->uid = $user->uid;
    $sms->timestamp = time();
    $sms->direction = SMS_PANEL_OUT;
    $sms->number = $outgoing['number'];
    $sms->message = $outgoing['message'];
    $sms->gateway = $gateway['identifier'];
    
    sms_save($sms);
  }
}

/**
 * Implementation of hook_SMS_PANEL_INcoming().
 */
function sms_panel_sms_panel_incoming($op, $number, $message, $options) {
  if ($op == 'post process') {
    $sms = new stdClass();
    $sms->uid = 0;
    $sms->number = $number;
    $sms->timestamp = time();
    $sms->message = $message;
    $sms->direction = SMS_PANEL_IN;
    $sms->gateway = sms_default_gateway();
    
    sms_save($sms);
  }
}

/**
 * Helper function to save a sms message to database.
 *
 * @param $sms
 *   SMS object to be saved.
 */
function sms_save($sms) {
  if (is_array($sms)) {
    $sms = (object) $sms;
  }
  
  $sms->timestamp = $sms->timestamp ? $sms->timestamp : time();
  drupal_write_record('sms_messages', $sms);
}

/**
 * Helper function to delete a sms message from database.
 *
 * @param $sid
 *   SMS object or identifier to be deleted.
 */
function sms_delete($sid) {
  global $user;
  $allowed = FALSE;
  $sms = sms_load($sid);
  
  switch ($sms->direction) {
    case SMS_PANEL_OUT:
      $allowed = (user_access('delete outgoing message logs')) ? TRUE : FALSE;
      break;
      
    case SMS_PANEL_IN:
      $allowed = (user_access('delete incoming message logs')) ? TRUE : FALSE;
      break;
  }
  
  if ($allowed) {
    $sid = is_object($sid) ? $sid->sid : $sid;
    db_query("DELETE FROM {sms_messages} WHERE sid = %d", $sid);
    drupal_set_message(t('The SMS message logs has been successfully deleted.'), 'status', FALSE);
  }
  else {
    drupal_set_message(t('You have not enough permission to delete the SMS message log.'), 'error', FALSE);
  }
}

/**
 * Helper function to load a sms message from database.
 *
 * @param $params
 *   The sid of the SMS message or an array of conditions to match against.
 * @param $flush
 *   Whether to flush the internal cache.
 *
 * @return
 *   The loaded SMS object or an array of SMS objects or FALSE on fail.
 *
 * @todo
 *   Extend to be able to match other conditions.
 */
function sms_load($params = array(), $flush = FALSE) {  
  static $cache = array();
  
  // Flush the internal cache, if set so.
  if ($flush) {
    $cache = array();
  }
  
  // Check for cache availablity or build the query.
  $arguments = array();
  if (is_numeric($params)) {
    if (isset($cache[$params])) {
      return (object) $cache[$params];
    }
    $conditions = 'sid = %d';
    $arguments[] = $params;
  }
  elseif (is_array($params)) {
    // Convert array formatted parameters into a query.
    foreach ($params as $key => $value) {
      if ($key == 'period' && isset($value['from'])) {
        $conditions[] = '(timestamp BETWEEN %d AND %d)';
        $arguments[] = $value['from'];
        $arguments[] = isset($value['to']) ? $value['to'] : time();
      }
      else {
        $conditions[] = db_escape_table($key) . " = '%s'";
        $arguments[] = $value;
      }
    }
    $conditions = implode(' AND ', $conditions);
  }
  else {
    return FALSE;
  }
  
  // Get and iterate through the results.
  $sms = array();
  $conditions = $conditions ? $conditions : 'TRUE';
  $results = db_query("SELECT * FROM {sms_messages} WHERE " . $conditions, $arguments);

  while ($sms_object = db_fetch_object($results)) {
    $sms[] = $sms_object;
  }
  unset($results);
  
  // Remove the array wrapper, if there were only one result.
  $count = count($sms);
  if ($count == 1) {
    $sms = $sms[0];
  }
  elseif (!$count) {
    return FALSE;
  }
  
  // Cache it.
  $cache[$sms->sid] = $sms;
  
  return $sms;
}

